CCS PCM C Compiler, Version 5.015, 5967               22-Apr-22 14:57

               Filename:   D:\LiHome\Version 1 codes\DALI LED dimmable driver pic16f684 code\SLAVE 684 - modified retransmision\slave.lst

               ROM used:   1868 words (91%)
                           Largest free fragment is 180
               RAM used:   65 (51%) at main() level
                           82 (64%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  06
0001:  MOVWF  0A
0002:  GOTO   67F
0003:  NOP
0004:  BTFSC  03.5
0005:  GOTO   00A
0006:  MOVWF  24
0007:  SWAPF  03,W
0008:  MOVWF  25
0009:  GOTO   00F
000A:  BCF    03.5
000B:  MOVWF  24
000C:  SWAPF  03,W
000D:  MOVWF  25
000E:  BSF    25.1
000F:  MOVF   0A,W
0010:  MOVWF  2B
0011:  CLRF   0A
0012:  BCF    03.7
0013:  SWAPF  24,F
0014:  MOVF   04,W
0015:  MOVWF  26
0016:  MOVF   20,W
0017:  MOVWF  27
0018:  MOVF   21,W
0019:  MOVWF  28
001A:  MOVF   22,W
001B:  MOVWF  29
001C:  MOVF   23,W
001D:  MOVWF  2A
001E:  BCF    03.5
001F:  BTFSS  0B.5
0020:  GOTO   023
0021:  BTFSC  0B.2
0022:  GOTO   146
0023:  BTFSS  0B.4
0024:  GOTO   027
0025:  BTFSC  0B.1
0026:  GOTO   040
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.0
002A:  GOTO   02D
002B:  BTFSC  0C.0
002C:  GOTO   079
002D:  MOVF   26,W
002E:  MOVWF  04
002F:  MOVF   27,W
0030:  MOVWF  20
0031:  MOVF   28,W
0032:  MOVWF  21
0033:  MOVF   29,W
0034:  MOVWF  22
0035:  MOVF   2A,W
0036:  MOVWF  23
0037:  MOVF   2B,W
0038:  MOVWF  0A
0039:  SWAPF  25,W
003A:  MOVWF  03
003B:  BCF    03.5
003C:  SWAPF  24,W
003D:  BTFSC  25.1
003E:  BSF    03.5
003F:  RETFIE
.................... #include <slave.h>					// Config file 
.................... #include <16F684.h> 
.................... //////////// Standard Header file for the PIC16F684 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F684 
*
0245:  CLRF   20
0246:  CLRF   21
0247:  MOVF   61,W
0248:  BCF    03.0
0249:  BTFSC  62.0
024A:  ADDWF  20,F
024B:  RRF    20,F
024C:  RRF    21,F
024D:  BTFSC  62.1
024E:  ADDWF  20,F
024F:  RRF    20,F
0250:  RRF    21,F
0251:  BTFSC  62.2
0252:  ADDWF  20,F
0253:  RRF    20,F
0254:  RRF    21,F
0255:  BTFSC  62.3
0256:  ADDWF  20,F
0257:  RRF    20,F
0258:  RRF    21,F
0259:  BTFSC  62.4
025A:  ADDWF  20,F
025B:  RRF    20,F
025C:  RRF    21,F
025D:  BTFSC  62.5
025E:  ADDWF  20,F
025F:  RRF    20,F
0260:  RRF    21,F
0261:  BTFSC  62.6
0262:  ADDWF  20,F
0263:  RRF    20,F
0264:  RRF    21,F
0265:  BTFSC  62.7
0266:  ADDWF  20,F
0267:  RRF    20,F
0268:  RRF    21,F
0269:  RETURN
....................  
.................... #list 
....................  
....................  
.................... #device adc=8 
....................  
.................... #FUSES WDT            // Watch dog timer enabled 
.................... #FUSES INTRC_IO       // Internal crystal osc <= 4mhz for PCM/PCH , 3mhz to 10 mhz for PCD 
.................... #FUSES NOPROTECT      // Code not protected from reading 
.................... #FUSES BROWNOUT       // Brownout reset enabled 
.................... #FUSES MCLR           // Master Clear enabled 
.................... #FUSES NOCPD          // No EE protection 
.................... #FUSES PUT            // Power up timer enabled 
.................... #FUSES NOIESO         // Internal External Switch Over mode disabled 
.................... #FUSES NOFCMEN        // Fail-safe clock monitor disabled 
....................  
.................... #use delay(clock=4000000) 
....................  
.................... #include<math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
069F:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... 																			// Code Version 1	v1.0 
....................  
.................... #use delay(clock=4000000)			// Internal clock of 4MHz 
*
0322:  MOVLW  12
0323:  SUBWF  62,F
0324:  BTFSS  03.0
0325:  GOTO   334
0326:  MOVLW  62
0327:  MOVWF  04
0328:  MOVLW  FC
0329:  ANDWF  00,F
032A:  BCF    03.0
032B:  RRF    00,F
032C:  RRF    00,F
032D:  MOVF   00,W
032E:  BTFSC  03.2
032F:  GOTO   334
0330:  GOTO   332
0331:  NOP
0332:  DECFSZ 00,F
0333:  GOTO   331
*
066A:  MOVLW  5F
066B:  MOVWF  04
066C:  MOVF   00,W
066D:  BTFSC  03.2
066E:  GOTO   67D
066F:  MOVLW  01
0670:  MOVWF  21
0671:  CLRF   20
0672:  DECFSZ 20,F
0673:  GOTO   672
0674:  DECFSZ 21,F
0675:  GOTO   671
0676:  MOVLW  4A
0677:  MOVWF  20
0678:  DECFSZ 20,F
0679:  GOTO   678
067A:  GOTO   67B
067B:  DECFSZ 00,F
067C:  GOTO   66F
....................  
.................... /////////////////////////////////////////////////////////////////////// CONFIGURATION PART START ///////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define Fixlampid   1 				// LAMP Address range 0-63 
.................... #define zoneid_init   210			// Zone Address range 207-223 
.................... #define device_type 4 				// Device type. 1 - normal led driver, 2 - fan driver, 3 - curtain driver, 4 - strip led driver, 5 - TRIAC MOSFET driver 
....................  
.................... #define G1 0b00000001 
.................... #define G2 0b00000000 
.................... #define rx pin_a1 
.................... #define tx pin_a0 
....................  
.................... #define MaxDuty  100 				// Maximum lux level 
.................... #define MinDuty  0					// Minimum lux level 
....................  
.................... 			/// EEPROM locations /// 
....................  
.................... #define PowerOnLevelStore   0           // Latest lux level of the device	 
.................... #define MinimumLevelStore   2			// Minimum lux level storage 
.................... #define MaximumLevelStore  	3 			// Maximum lux level storage 
.................... #define FadeRateStore      	4  			// Faderate storage 
.................... #define ShortAddressStore  	6  			// Individual deviceID storage 
.................... #define Group_07Store    	7			// Group address first byte storage 
.................... #define Group_815Store  	8			// Group address second byte storage 
.................... #define SceneStore  		9			// Scenes storage starting location 
.................... #define ZoneIDStore 		32			// Zone ID storage location 
....................  
.................... /////////////////////////////////////////////////////////////////////// CONFIGURATION PART END /////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #byte dutyreg = 0x15 
....................   
.................... #bit intf = 0x0b.1 
.................... #bit timerOnOff =0x10.0 
....................  
.................... int1 oddevenbit,a,atmp,b,error_flag,over_flowflag; 
.................... unsigned int8 dataCount; 
.................... char data[3],bitcount,tout; 
.................... unsigned char duty; 
....................  
.................... unsigned int16 SetPower,power; 
....................  
.................... char settling_time,i,dly=4,j; 
.................... int1 txmit_error=0; 
.................... char tx_buffer[3]; 
.................... char r_a,currentSceen; 
.................... char l_st; 
.................... char command_st,RetryCount; 
.................... char FadeRateCount=1; 
....................  
.................... char zoneid=zoneid_init; 
....................  
....................  
.................... char stopBitCount,address ,command,databyte; 
.................... int1 dataready,forwrdFrameFlag,backwardFrameFlag ,masterFlag ; 
.................... int16 readDly=300; 
.................... int16 GroupSelectReg; 
.................... char gindex; 
....................  
.................... /////// new  ////// 
.................... int txmit_count=0; 
.................... int error_value=0; 
.................... /////////////////// 
....................  
.................... char MinimumLevel; 
.................... char MaximumLevel; 
.................... char FadeRate; 
.................... char PowerOnLevel; 
.................... char DTR,DwriteLocation,DTR_Ready; 
....................  
.................... char lampid  = Fixlampid; 
.................... int1 reset_flag=0; 
....................  
.................... void readData(void); 
.................... void init(void); 
.................... void handle(void ); 
.................... void copyData(void); 
.................... void commands(void); 
.................... void txmit(char priority,char length); 
.................... void txmit1(void); 
.................... void txmit0(void); 
.................... void stopbit(void); 
.................... void lamp_on(void); 
.................... void lamp_off(void); 
.................... void startBit(void); 
.................... void init_from_eeprom(void); 
.................... void SetDimmLevel(unsigned int dimPesentage); 
....................  
.................... #rom  0x2100={MaxDuty,50,MinDuty,Maxduty,5,6,Fixlampid,G1,G2,6,7,8}				// Initial EEPROM values 
.................... #rom  0x2120={zoneid_init} 
....................  
.................... #int_EXT 
.................... EXT_isr()  
.................... {  
.................... 	output_toggle(pin_c3); 
*
0040:  BSF    03.5
0041:  BCF    07.3
0042:  MOVLW  08
0043:  BCF    03.5
0044:  XORWF  07,F
.................... 	clear_interrupt(int_ext); 
0045:  BCF    0B.1
.................... 	disable_interrupts(int_ext); 
0046:  BCF    0B.4
.................... 	disable_interrupts(INT_RTCC); 
0047:  BCF    0B.5
.................... 	bitcount=0; 
0048:  CLRF   36
.................... 	setup_timer_1(T1_internal|T1_div_by_1); 
0049:  MOVLW  05
004A:  MOVWF  10
.................... 	set_timer1(0xffff-840); 					//858  880///old value 923 
004B:  CLRF   0E
004C:  MOVLW  FC
004D:  MOVWF  0F
004E:  MOVLW  B7
004F:  MOVWF  0E
.................... 	enable_interrupts(int_timer1); 
0050:  BSF    03.5
0051:  BSF    0C.0
.................... 	stopBitCount = 0; 
0052:  BCF    03.5
0053:  CLRF   4B
.................... 	oddevenbit=1; 
0054:  BSF    31.0
.................... 	data[0]=0; 
0055:  CLRF   33
.................... 	data[1]=0; 
0056:  CLRF   34
.................... 	data[2]=0; 
0057:  CLRF   35
.................... 	tout=0 ; 
0058:  CLRF   37
.................... 	datacount = 0;    
0059:  CLRF   32
.................... 	settling_time = 0;  
005A:  CLRF   3D
.................... } 
....................  
005B:  BCF    0B.1
005C:  BCF    0A.3
005D:  GOTO   02D
.................... #int_TIMER1 
.................... TIMER1_isr() 
.................... { 
.................... 	output_toggle(pin_c2); 
*
0079:  BSF    03.5
007A:  BCF    07.2
007B:  MOVLW  04
007C:  BCF    03.5
007D:  XORWF  07,F
.................... 	readDly=20; 
007E:  CLRF   51
007F:  MOVLW  14
0080:  MOVWF  50
.................... 	error_flag=0; 
0081:  BCF    31.4
.................... 		if(oddevenbit==1) 
0082:  BTFSS  31.0
0083:  GOTO   0BF
.................... 		{ 
.................... 			a=input(rx);  
0084:  BSF    03.5
0085:  BSF    05.1
0086:  BCF    03.5
0087:  BCF    31.1
0088:  BTFSC  05.1
0089:  BSF    31.1
.................... 			atmp=a ;           
008A:  BCF    31.2
008B:  BTFSC  31.1
008C:  BSF    31.2
.................... 			oddevenbit=0 ; 
008D:  BCF    31.0
.................... 			 
.................... 					if(atmp) 
008E:  BTFSS  31.2
008F:  GOTO   0A6
.................... 					{ 
.................... 						while(atmp) 
0090:  BTFSS  31.2
0091:  GOTO   0A5
.................... 							{ 
.................... 								atmp=input(rx); 
0092:  BSF    03.5
0093:  BSF    05.1
0094:  BCF    03.5
0095:  BCF    31.2
0096:  BTFSC  05.1
0097:  BSF    31.2
.................... 								if(readDly>0) 
0098:  MOVF   50,F
0099:  BTFSS  03.2
009A:  GOTO   09E
009B:  MOVF   51,F
009C:  BTFSC  03.2
009D:  GOTO   0A3
.................... 									readDly--; 
009E:  MOVF   50,W
009F:  BTFSC  03.2
00A0:  DECF   51,F
00A1:  DECF   50,F
00A2:  GOTO   0A4
.................... 								else 
.................... 									atmp=0; 
00A3:  BCF    31.2
00A4:  GOTO   090
.................... 									 
.................... 							} 
.................... 					}          
00A5:  GOTO   0B7
.................... 					else 
.................... 					{ 
.................... 						while(!atmp) 
00A6:  BTFSC  31.2
00A7:  GOTO   0B7
.................... 							{ 
.................... 								atmp=input(rx); 
00A8:  BSF    03.5
00A9:  BSF    05.1
00AA:  BCF    03.5
00AB:  BCF    31.2
00AC:  BTFSC  05.1
00AD:  BSF    31.2
.................... 								readDly--; 
00AE:  MOVF   50,W
00AF:  BTFSC  03.2
00B0:  DECF   51,F
00B1:  DECFSZ 50,F
.................... 									if(readdly==0) 
00B2:  GOTO   0B6
00B3:  MOVF   51,F
00B4:  BTFSC  03.2
.................... 										{ 
.................... 										atmp=1; 
00B5:  BSF    31.2
.................... 										}	 
00B6:  GOTO   0A6
.................... 							} 
.................... 					} 
.................... 	 
.................... 				setup_timer_1(T1_internal|T1_div_by_1);			//set timer1 with 1us least count 
00B7:  MOVLW  05
00B8:  MOVWF  10
.................... 				set_timer1(0xffff-150);  						//374 355 350 old value 150	 
00B9:  CLRF   0E
00BA:  MOVLW  FF
00BB:  MOVWF  0F
00BC:  MOVLW  69
00BD:  MOVWF  0E
.................... 		} 
00BE:  GOTO   141
.................... 		else 
.................... 		{  
.................... 			b=input(rx) ; 										// store data line status in the second half 
00BF:  BSF    03.5
00C0:  BSF    05.1
00C1:  BCF    03.5
00C2:  BCF    31.3
00C3:  BTFSC  05.1
00C4:  BSF    31.3
.................... 			oddevenbit=1; 
00C5:  BSF    31.0
.................... 			setup_timer_1(T1_internal|T1_div_by_1); 
00C6:  MOVLW  05
00C7:  MOVWF  10
.................... 			set_timer1(0xffff-350);  							// delay  till the next call st to 73 us/////old value 350 
00C8:  CLRF   0E
00C9:  MOVLW  FE
00CA:  MOVWF  0F
00CB:  MOVLW  A1
00CC:  MOVWF  0E
.................... 			readData();  										// function  get the data from the conditions of a and b 
.................... 						 
.................... 		} 
.................... 	return(0); 
*
0141:  MOVLW  00
0142:  MOVWF  21
.................... } 
....................  
0143:  BCF    0C.0
0144:  BCF    0A.3
0145:  GOTO   02D
.................... #int_RTCC 
.................... RTCC_isr() 
.................... {	 
.................... 	reset_flag=1; 
0146:  BSF    4F.3
.................... 	if(FadeRateCount>0) 
0147:  MOVF   49,F
0148:  BTFSC  03.2
0149:  GOTO   14C
.................... 	{ 
.................... 		FadeRateCount--; 
014A:  DECF   49,F
.................... 	} 
014B:  GOTO   1A4
.................... 	else 
.................... 	{ 
.................... 		 
.................... 		FadeRateCount=FadeRate; 
014C:  MOVF   59,W
014D:  MOVWF  49
.................... 		if(SetPower <Power) 
014E:  MOVF   3A,W
014F:  SUBWF  3C,W
0150:  BTFSS  03.0
0151:  GOTO   16F
0152:  BTFSS  03.2
0153:  GOTO   158
0154:  MOVF   3B,W
0155:  SUBWF  39,W
0156:  BTFSC  03.0
0157:  GOTO   16F
.................... 		{	 
.................... 				SetPower++;	 
0158:  INCF   39,F
0159:  BTFSC  03.2
015A:  INCF   3A,F
.................... 				set_pwm1_duty(SetPower ); 
015B:  MOVF   3A,W
015C:  MOVWF  22
015D:  MOVF   39,W
015E:  MOVWF  21
015F:  RRF    22,F
0160:  RRF    21,F
0161:  RRF    22,F
0162:  RRF    21,F
0163:  RRF    22,F
0164:  MOVF   21,W
0165:  MOVWF  13
0166:  RRF    22,F
0167:  RRF    22,W
0168:  ANDLW  30
0169:  MOVWF  20
016A:  MOVF   15,W
016B:  ANDLW  CF
016C:  IORWF  20,W
016D:  MOVWF  15
.................... 		} 
016E:  GOTO   1A4
.................... 		else if(SetPower > Power) 
016F:  MOVF   3C,W
0170:  SUBWF  3A,W
0171:  BTFSS  03.0
0172:  GOTO   191
0173:  BTFSS  03.2
0174:  GOTO   179
0175:  MOVF   39,W
0176:  SUBWF  3B,W
0177:  BTFSC  03.0
0178:  GOTO   191
.................... 		{	 
.................... 				SetPower--;	 
0179:  MOVF   39,W
017A:  BTFSC  03.2
017B:  DECF   3A,F
017C:  DECF   39,F
.................... 				set_pwm1_duty(SetPower ); 
017D:  MOVF   3A,W
017E:  MOVWF  22
017F:  MOVF   39,W
0180:  MOVWF  21
0181:  RRF    22,F
0182:  RRF    21,F
0183:  RRF    22,F
0184:  RRF    21,F
0185:  RRF    22,F
0186:  MOVF   21,W
0187:  MOVWF  13
0188:  RRF    22,F
0189:  RRF    22,W
018A:  ANDLW  30
018B:  MOVWF  20
018C:  MOVF   15,W
018D:  ANDLW  CF
018E:  IORWF  20,W
018F:  MOVWF  15
.................... 		} 
0190:  GOTO   1A4
.................... 		else 
.................... 		{ 
.................... 				set_pwm1_duty(SetPower ); 
0191:  MOVF   3A,W
0192:  MOVWF  22
0193:  MOVF   39,W
0194:  MOVWF  21
0195:  RRF    22,F
0196:  RRF    21,F
0197:  RRF    22,F
0198:  RRF    21,F
0199:  RRF    22,F
019A:  MOVF   21,W
019B:  MOVWF  13
019C:  RRF    22,F
019D:  RRF    22,W
019E:  ANDLW  30
019F:  MOVWF  20
01A0:  MOVF   15,W
01A1:  ANDLW  CF
01A2:  IORWF  20,W
01A3:  MOVWF  15
.................... 		} 
.................... 	} 
.................... 	dly--; 
01A4:  DECFSZ 3F,F
....................   	if (dly == 0) 
01A5:  GOTO   1AC
....................   	{	 
....................       dly = 4; 
01A6:  MOVLW  04
01A7:  MOVWF  3F
....................       if(settling_time < 250) 
01A8:  MOVF   3D,W
01A9:  SUBLW  F9
01AA:  BTFSC  03.0
....................       { 
....................           settling_time++; 
01AB:  INCF   3D,F
....................       }               
....................    } 
....................  
01AC:  BCF    0B.2
01AD:  BCF    0A.3
01AE:  GOTO   02D
.................... } 
....................  
.................... void main(void) 
*
067F:  MOVF   03,W
0680:  ANDLW  1F
0681:  MOVWF  03
0682:  MOVLW  61
0683:  BSF    03.5
0684:  MOVWF  0F
0685:  MOVF   0F,W
0686:  MOVLW  04
0687:  BCF    03.5
0688:  MOVWF  3F
0689:  BCF    31.6
068A:  MOVLW  01
068B:  MOVWF  49
068C:  MOVLW  D2
068D:  MOVWF  4A
068E:  MOVLW  01
068F:  MOVWF  51
0690:  MOVLW  2C
0691:  MOVWF  50
0692:  CLRF   55
0693:  CLRF   56
0694:  MOVLW  01
0695:  MOVWF  5E
0696:  BCF    4F.3
0697:  BCF    1F.6
0698:  MOVLW  00
0699:  BSF    03.5
069A:  MOVWF  11
069B:  BCF    03.5
069C:  CLRF   1A
069D:  MOVLW  07
069E:  MOVWF  19
....................  
.................... { 
.................... 	setup_wdt(WDT_ON); 
*
06A0:  BSF    18.0
.................... 	setup_wdt(WDT_72MS|WDT_TIMES_16);		//~1.1 s reset	 
06A1:  MOVLW  11
06A2:  MOVWF  18
06A3:  MOVLW  0A
06A4:  MOVWF  20
06A5:  CLRF   01
06A6:  MOVLW  81
06A7:  MOVWF  04
06A8:  MOVF   00,W
06A9:  ANDLW  F0
06AA:  IORLW  07
06AB:  MOVWF  00
06AC:  CLRWDT
06AD:  MOVF   00,W
06AE:  ANDLW  F7
06AF:  BTFSC  20.3
06B0:  ANDLW  F0
06B1:  IORWF  20,W
06B2:  MOVWF  00
.................... 	 
.................... 	init_from_eeprom(); 
06B3:  CALL   1AF
.................... 	init();		 
06B4:  GOTO   21D
.................... 	GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
06B5:  MOVLW  08
06B6:  BSF    03.5
06B7:  MOVWF  1B
06B8:  BCF    1C.7
06B9:  BSF    1C.0
06BA:  MOVF   1A,W
06BB:  BCF    03.5
06BC:  MOVWF  5F
06BD:  MOVLW  07
06BE:  BSF    03.5
06BF:  MOVWF  1B
06C0:  BCF    1C.7
06C1:  BSF    1C.0
06C2:  MOVF   1A,W
06C3:  BCF    03.5
06C4:  MOVWF  60
06C5:  MOVF   5F,W
06C6:  MOVWF  53
06C7:  MOVF   60,W
06C8:  MOVWF  52
.................... 	PowerOnLevel = read_EEPROM (PowerOnLevelStore); 
06C9:  BSF    03.5
06CA:  CLRF   1B
06CB:  BCF    1C.7
06CC:  BSF    1C.0
06CD:  MOVF   1A,W
06CE:  BCF    03.5
06CF:  MOVWF  5A
....................  
.................... 	if(PowerOnLevel<= 2) 
06D0:  MOVF   5A,W
06D1:  SUBLW  02
06D2:  BTFSS  03.0
06D3:  GOTO   6EC
.................... 	{ 
.................... 		duty=0;	 
06D4:  CLRF   38
.................... 		lamp_off(); 
06D5:  CALL   2BC
.................... 		SetPower =0; 
06D6:  CLRF   3A
06D7:  CLRF   39
.................... 		set_pwm1_duty(SetPower );		 
06D8:  MOVF   3A,W
06D9:  MOVWF  22
06DA:  MOVF   39,W
06DB:  MOVWF  21
06DC:  RRF    22,F
06DD:  RRF    21,F
06DE:  RRF    22,F
06DF:  RRF    21,F
06E0:  RRF    22,F
06E1:  MOVF   21,W
06E2:  MOVWF  13
06E3:  RRF    22,F
06E4:  RRF    22,W
06E5:  ANDLW  30
06E6:  MOVWF  20
06E7:  MOVF   15,W
06E8:  ANDLW  CF
06E9:  IORWF  20,W
06EA:  MOVWF  15
.................... 	} 
06EB:  GOTO   70B
.................... 	else 
.................... 	{ 
.................... 		duty = PowerOnLevel; 
06EC:  MOVF   5A,W
06ED:  MOVWF  38
.................... 		SetDimmLevel(duty);	 
06EE:  MOVF   38,W
06EF:  MOVWF  5F
06F0:  CALL   26A
.................... 		set_pwm1_duty(Power ); 
06F1:  MOVF   3C,W
06F2:  MOVWF  22
06F3:  MOVF   3B,W
06F4:  MOVWF  21
06F5:  RRF    22,F
06F6:  RRF    21,F
06F7:  RRF    22,F
06F8:  RRF    21,F
06F9:  RRF    22,F
06FA:  MOVF   21,W
06FB:  MOVWF  13
06FC:  RRF    22,F
06FD:  RRF    22,W
06FE:  ANDLW  30
06FF:  MOVWF  20
0700:  MOVF   15,W
0701:  ANDLW  CF
0702:  IORWF  20,W
0703:  MOVWF  15
.................... 		SetPower = Power; 
0704:  MOVF   3C,W
0705:  MOVWF  3A
0706:  MOVF   3B,W
0707:  MOVWF  39
.................... 		FadeRateCount=FadeRate;	 
0708:  MOVF   59,W
0709:  MOVWF  49
.................... 		lamp_on();		 
070A:  CALL   2C1
.................... 	} 
....................  
.................... start: 
....................  
.................... 	if(reset_flag==1) 
070B:  BTFSS  4F.3
070C:  GOTO   70F
.................... 	{ 
.................... 	restart_wdt();  
070D:  CLRWDT
.................... 	reset_flag=0; 
070E:  BCF    4F.3
.................... 	}		 
.................... 	if (dataReady ==1) 
070F:  BTFSS  31.7
0710:  GOTO   73D
.................... 	{ 
.................... 		if(address == 0xff) 
0711:  INCFSZ 4C,W
0712:  GOTO   715
.................... 		{ 
.................... 			handle();  
0713:  CALL   3A6
.................... 		}		 
0714:  GOTO   73C
.................... 		else if(address==lampid)		{ 
0715:  MOVF   5E,W
0716:  SUBWF  4C,W
0717:  BTFSS  03.2
0718:  GOTO   71B
.................... 			 
.................... 			handle();  
0719:  CALL   3A6
.................... 		}		 
071A:  GOTO   73C
....................     	else if(address == zoneid) 
071B:  MOVF   4A,W
071C:  SUBWF  4C,W
071D:  BTFSS  03.2
071E:  GOTO   721
.................... 		{ 
.................... 			handle();	 
071F:  CALL   3A6
.................... 		} 
0720:  GOTO   73C
.................... 		else if(address>191 && address<208) 
0721:  MOVF   4C,W
0722:  SUBLW  BF
0723:  BTFSC  03.0
0724:  GOTO   73C
0725:  MOVF   4C,W
0726:  SUBLW  CF
0727:  BTFSS  03.0
0728:  GOTO   73C
.................... 		{	 
.................... 			gindex = address &0x0F; 
0729:  MOVF   4C,W
072A:  ANDLW  0F
072B:  MOVWF  54
.................... 			if ( bit_test (GroupSelectReg, gindex)==1) 
072C:  MOVF   53,W
072D:  MOVWF  23
072E:  MOVF   52,W
072F:  MOVWF  22
0730:  MOVF   54,W
0731:  MOVWF  20
0732:  BTFSC  03.2
0733:  GOTO   739
0734:  BCF    03.0
0735:  RRF    23,F
0736:  RRF    22,F
0737:  DECFSZ 20,F
0738:  GOTO   734
0739:  MOVF   22,W
073A:  BTFSC  22.0
.................... 			{ 				 
.................... 				handle(); 
073B:  CALL   3A6
.................... 			}	 
.................... 		} 
.................... 		dataReady =0; 
073C:  BCF    31.7
.................... 	} 
.................... 	if(txmit_error==1 && txmit_count<5) 
073D:  BTFSS  31.6
073E:  GOTO   749
073F:  MOVF   55,W
0740:  SUBLW  04
0741:  BTFSS  03.0
0742:  GOTO   749
.................... 	{ 
.................... 		txmit_count++; 
0743:  INCF   55,F
.................... 		txmit(2,2); 
0744:  MOVLW  02
0745:  MOVWF  5F
0746:  MOVWF  60
0747:  CALL   337
.................... 	}	 
0748:  GOTO   74A
.................... 	else 
.................... 	{ 
.................... 		txmit_count=0; 
0749:  CLRF   55
.................... 	}	 
.................... 	goto start; 
074A:  GOTO   70B
.................... } 
....................  
074B:  SLEEP
.................... void init(void) 
.................... { 
.................... 	setup_timer_2(T2_DIV_BY_16,124,1);  // 500 hz //old value T2_DIV_BY_16 //old value 124,10 
*
021D:  MOVLW  00
021E:  MOVWF  21
021F:  IORLW  06
0220:  MOVWF  12
0221:  MOVLW  7C
0222:  BSF    03.5
0223:  MOVWF  12
....................  	setup_ccp1(CCP_PWM);	 
0224:  BCF    07.5
0225:  BCF    03.5
0226:  BCF    07.5
0227:  MOVLW  0C
0228:  MOVWF  15
0229:  CLRF   16
022A:  CLRF   17
.................... 	setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
022B:  BSF    03.5
022C:  MOVF   01,W
022D:  ANDLW  C7
022E:  IORLW  08
022F:  MOVWF  01
.................... 	setup_timer_1(T1_internal|T1_div_by_1); 
0230:  MOVLW  05
0231:  BCF    03.5
0232:  MOVWF  10
.................... 	timerOnOff=0; 
0233:  BCF    10.0
.................... 	clear_interrupt(int_ext); 
0234:  BCF    0B.1
.................... 	ext_int_edge( H_TO_L );	 
0235:  BSF    03.5
0236:  BCF    01.6
.................... 	enable_interrupts(INT_EXT); 
0237:  BCF    03.5
0238:  BSF    0B.4
.................... 	enable_interrupts(INT_RTCC); 
0239:  BSF    0B.5
.................... 	disable_interrupts(INT_TIMER2); 
023A:  BSF    03.5
023B:  BCF    0C.1
.................... 	enable_interrupts(global);	 
023C:  MOVLW  C0
023D:  BCF    03.5
023E:  IORWF  0B,F
.................... 	settling_time =23; 
023F:  MOVLW  17
0240:  MOVWF  3D
.................... 	dataReady =0; 
0241:  BCF    31.7
.................... 	SetPower=0;     
0242:  CLRF   3A
0243:  CLRF   39
.................... 	return; 
0244:  GOTO   6B5 (RETURN)
.................... } 
....................  
.................... void handle(void ) 
....................  
.................... { 
.................... 	commands(); 
.................... 	delay_ms(2); 
*
0668:  MOVLW  02
0669:  MOVWF  5F
.................... 	RetryCount =0; 
*
067D:  CLRF   48
.................... 	return; 
067E:  RETURN
.................... } 
....................  
....................  
.................... //				trnsmission of  bit 1			// 
.................... /********************************************************************* 
....................  * Function:       void txmit0(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  bit 1 to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
....................  
.................... void txmit1(void) 
....................  
.................... {      
....................   	txmit_error = 0; 
*
02C7:  BCF    31.6
.................... 	if (input(rx)==1) 
02C8:  BSF    03.5
02C9:  BSF    05.1
02CA:  BCF    03.5
02CB:  BTFSS  05.1
02CC:  GOTO   2D1
.................... 	{   
.................... 		output_bit(tx,0); 
02CD:  BCF    05.0
02CE:  BSF    03.5
02CF:  BCF    05.0
02D0:  BCF    03.5
.................... 	} 
.................... 	delay_us(79); 
02D1:  MOVLW  19
02D2:  MOVWF  20
02D3:  DECFSZ 20,F
02D4:  GOTO   2D3
02D5:  GOTO   2D6
02D6:  NOP
.................... 	if (input(rx)==1) 
02D7:  BSF    03.5
02D8:  BSF    05.1
02D9:  BCF    03.5
02DA:  BTFSS  05.1
02DB:  GOTO   2E2
.................... 	{ 
.................... 		output_bit(tx,1); 
02DC:  BSF    05.0
02DD:  BSF    03.5
02DE:  BCF    05.0
.................... 		txmit_error = 1; 
02DF:  BCF    03.5
02E0:  BSF    31.6
.................... 		return; 
02E1:  GOTO   319
.................... 	}			   
.................... 	delay_us(290);		//345 
02E2:  MOVLW  60
02E3:  MOVWF  20
02E4:  DECFSZ 20,F
02E5:  GOTO   2E4
02E6:  NOP
.................... 	if (input(rx)==0) 
02E7:  BSF    03.5
02E8:  BSF    05.1
02E9:  BCF    03.5
02EA:  BTFSC  05.1
02EB:  GOTO   2F1
.................... 	{ 
.................... 		output_bit(tx,1); 
02EC:  BSF    05.0
02ED:  BSF    03.5
02EE:  BCF    05.0
.................... 	} 
02EF:  GOTO   2F8
02F0:  BCF    03.5
.................... 	else 
.................... 	{ 
.................... 		output_bit(tx,1); 
02F1:  BSF    05.0
02F2:  BSF    03.5
02F3:  BCF    05.0
.................... 		txmit_error = 1; 
02F4:  BCF    03.5
02F5:  BSF    31.6
.................... 		return; 
02F6:  GOTO   319
02F7:  BSF    03.5
.................... 	} 
.................... 	delay_us(79); 
02F8:  MOVLW  19
02F9:  BCF    03.5
02FA:  MOVWF  20
02FB:  DECFSZ 20,F
02FC:  GOTO   2FB
02FD:  GOTO   2FE
02FE:  NOP
.................... 	if (input(rx)==0) 
02FF:  BSF    03.5
0300:  BSF    05.1
0301:  BCF    03.5
0302:  BTFSC  05.1
0303:  GOTO   30A
.................... 	{ 
.................... 		output_bit(tx,1); 
0304:  BSF    05.0
0305:  BSF    03.5
0306:  BCF    05.0
.................... 		txmit_error = 1; 
0307:  BCF    03.5
0308:  BSF    31.6
.................... 		return; 
0309:  GOTO   319
.................... 	} 
....................     delay_us(290); 
030A:  MOVLW  60
030B:  MOVWF  20
030C:  DECFSZ 20,F
030D:  GOTO   30C
030E:  NOP
.................... 	if (input(rx)==0) 
030F:  BSF    03.5
0310:  BSF    05.1
0311:  BCF    03.5
0312:  BTFSC  05.1
0313:  GOTO   319
.................... 	{ 
.................... 		output_bit(tx,1); 
0314:  BSF    05.0
0315:  BSF    03.5
0316:  BCF    05.0
.................... 		txmit_error = 1; 
0317:  BCF    03.5
0318:  BSF    31.6
.................... 		return; 
.................... 	} 
....................     return; 
0319:  RETURN
.................... } 
....................  
....................  
.................... //         transmission of 0 to the bus      // 
.................... /********************************************************************* 
....................  * Function:       void txmit0(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  0 bit to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
....................  
.................... void txmit0(void) 
....................  
.................... { 
.................... 	txmit_error = 0;	 
*
0353:  BCF    31.6
.................... 	output_bit(tx,1); 
0354:  BSF    05.0
0355:  BSF    03.5
0356:  BCF    05.0
.................... 	delay_us(79); 
0357:  MOVLW  19
0358:  BCF    03.5
0359:  MOVWF  20
035A:  DECFSZ 20,F
035B:  GOTO   35A
035C:  GOTO   35D
035D:  NOP
.................... 	if (input(rx)!=1) 
035E:  BSF    03.5
035F:  BSF    05.1
0360:  BCF    03.5
0361:  BTFSC  05.1
0362:  GOTO   365
.................... 	{		 
.................... 		txmit_error = 1; 
0363:  BSF    31.6
.................... 		return; 
0364:  GOTO   394
.................... 	}    
.................... 	delay_us(290); 
0365:  MOVLW  60
0366:  MOVWF  20
0367:  DECFSZ 20,F
0368:  GOTO   367
0369:  NOP
.................... 	if (input(rx)==1) 
036A:  BSF    03.5
036B:  BSF    05.1
036C:  BCF    03.5
036D:  BTFSS  05.1
036E:  GOTO   374
.................... 	{ 
.................... 		output_bit(tx,0); 
036F:  BCF    05.0
0370:  BSF    03.5
0371:  BCF    05.0
.................... 	} 
0372:  GOTO   37B
0373:  BCF    03.5
....................     else 
.................... 	{ 
.................... 		output_bit(tx,1); 
0374:  BSF    05.0
0375:  BSF    03.5
0376:  BCF    05.0
.................... 		txmit_error = 1; 
0377:  BCF    03.5
0378:  BSF    31.6
.................... 		return; 
0379:  GOTO   394
037A:  BSF    03.5
.................... 	} 
....................     delay_us(79); 
037B:  MOVLW  19
037C:  BCF    03.5
037D:  MOVWF  20
037E:  DECFSZ 20,F
037F:  GOTO   37E
0380:  GOTO   381
0381:  NOP
....................     if (input(rx)==1) 
0382:  BSF    03.5
0383:  BSF    05.1
0384:  BCF    03.5
0385:  BTFSS  05.1
0386:  GOTO   389
.................... 	{		 
.................... 		txmit_error = 1; 
0387:  BSF    31.6
.................... 		return; 
0388:  GOTO   394
.................... 	} 
....................     delay_us(290); 
0389:  MOVLW  60
038A:  MOVWF  20
038B:  DECFSZ 20,F
038C:  GOTO   38B
038D:  NOP
.................... 	if (input(rx)==1) 
038E:  BSF    03.5
038F:  BSF    05.1
0390:  BCF    03.5
0391:  BTFSS  05.1
0392:  GOTO   394
.................... 	{		 
.................... 		txmit_error = 1; 
0393:  BSF    31.6
.................... 		return; 
.................... 	} 
....................     return; 
.................... } 
.................... //----------------------------------------------------------------------------- 
....................                    // txmit2 bit 
.................... //----------------------------------------------------------------------------- 
....................  
.................... void txmit(char priority,char length) 
.................... { 	 
....................      j= 8*length; 
*
0337:  RLF    60,W
0338:  MOVWF  40
0339:  RLF    40,F
033A:  RLF    40,F
033B:  MOVLW  F8
033C:  ANDWF  40,F
.................... 	 while (settling_time < 12+Fixlampid);     // priority 
033D:  MOVF   3D,W
033E:  SUBLW  0C
033F:  BTFSC  03.0
0340:  GOTO   33D
....................      disable_interrupts(global); 
0341:  BCF    0B.6
0342:  BCF    0B.7
0343:  BTFSC  0B.7
0344:  GOTO   342
....................      txmit1();        // start bit   
0345:  CALL   2C7
....................      for(i=0;i<j;i++) 
0346:  CLRF   3E
0347:  MOVF   40,W
0348:  SUBWF  3E,W
0349:  BTFSC  03.0
034A:  GOTO   398
....................          { 
....................             if (shift_left(tx_buffer,3,1)==1) 
034B:  BSF    03.0
034C:  RLF    41,F
034D:  RLF    42,F
034E:  RLF    43,F
034F:  BTFSS  03.0
0350:  GOTO   353
....................             { 
....................                  txmit1(); 
0351:  CALL   2C7
....................             } 
0352:  GOTO   394
....................             else 
....................             { 
....................                   txmit0(); 
....................             } 
....................             if (txmit_error ==1) 
*
0394:  BTFSC  31.6
....................             { 
....................                goto rr; 
0395:  GOTO   39C
....................             }		 
0396:  INCF   3E,F
0397:  GOTO   347
....................          }         
.................... 	    stopbit();     
0398:  CALL   31A
.................... 	    stopbit();  
0399:  CALL   31A
.................... 		stopbit();  
039A:  CALL   31A
.................... 		stopbit(); 
039B:  CALL   31A
.................... 	rr: output_bit(tx,1); 
039C:  BSF    05.0
039D:  BSF    03.5
039E:  BCF    05.0
.................... 		settling_time = 0; 
039F:  BCF    03.5
03A0:  CLRF   3D
.................... 	    intf =0; 
03A1:  BCF    0B.1
.................... 	    enable_interrupts(global);	 
03A2:  MOVLW  C0
03A3:  IORWF  0B,F
.................... 		enable_interrupts(INT_RTCC); 
03A4:  BSF    0B.5
.................... 	    return; 
03A5:  RETURN
.................... } 
....................  
.................... //-------------------------------------------------------------------------- 
....................           // stop bit function // 
.................... //-------------------------------------------------------------------------- 
.................... void  stopbit(void) 
.................... { 
....................       output_bit(tx,1); 
*
031A:  BSF    05.0
031B:  BSF    03.5
031C:  BCF    05.0
....................       delay_us(830); 
031D:  MOVLW  05
031E:  BCF    03.5
031F:  MOVWF  61
0320:  MOVLW  A3
0321:  MOVWF  62
*
0334:  DECFSZ 61,F
0335:  GOTO   320
....................       return; 
0336:  RETURN
.................... } 
.................... //-------------------------------------------------------------------------- 
....................  
....................  
.................... void readData(void) 
.................... {  
....................       error_flag=0; 
*
00CD:  BCF    31.4
....................       datacount++; 
00CE:  INCF   32,F
....................       forwrdFrameFlag = 0; 
00CF:  BCF    4F.0
.................... 	  backwardFrameFlag =0; 
00D0:  BCF    4F.1
....................       if(datacount< 27) 
00D1:  MOVF   32,W
00D2:  SUBLW  1A
00D3:  BTFSS  03.0
00D4:  GOTO   138
....................       { 
....................          if((a==0 )&& (b==1)) 
00D5:  BTFSC  31.1
00D6:  GOTO   0DE
00D7:  BTFSS  31.3
00D8:  GOTO   0DE
....................          { 
....................             shift_left(data,3,1);  // a one detected on bus  
00D9:  BSF    03.0
00DA:  RLF    33,F
00DB:  RLF    34,F
00DC:  RLF    35,F
....................          } 
00DD:  GOTO   137
....................          else if((a==1)&&(b==0)) 
00DE:  BTFSS  31.1
00DF:  GOTO   0E7
00E0:  BTFSC  31.3
00E1:  GOTO   0E7
....................          { 
....................             shift_left(data,3,0);  // a zero is detected on the bus  
00E2:  BCF    03.0
00E3:  RLF    33,F
00E4:  RLF    34,F
00E5:  RLF    35,F
....................          } 
00E6:  GOTO   137
....................          else if ( a==1 && b==1) 
00E7:  BTFSS  31.1
00E8:  GOTO   12E
00E9:  BTFSS  31.3
00EA:  GOTO   12E
....................          { 
....................             switch (datacount) 
00EB:  MOVF   32,W
00EC:  XORLW  11
00ED:  BTFSC  03.2
00EE:  GOTO   0F9
00EF:  XORLW  03
00F0:  BTFSC  03.2
00F1:  GOTO   0FB
00F2:  XORLW  0B
00F3:  BTFSC  03.2
00F4:  GOTO   10F
00F5:  XORLW  03
00F6:  BTFSC  03.2
00F7:  GOTO   111
00F8:  GOTO   124
....................             { 
....................                case 17: 
....................                { 
....................                      stopBitCount ++; 
00F9:  INCF   4B,F
....................                      break; 
00FA:  GOTO   12D
....................                } 
....................                case 18: 
....................                { 
....................                   stopBitCount ++; 
00FB:  INCF   4B,F
....................                   if(stopBitCount == 2) 
00FC:  MOVF   4B,W
00FD:  SUBLW  02
00FE:  BTFSS  03.2
00FF:  GOTO   107
....................                   { 
....................                         r_a=1;  
0100:  MOVLW  01
0101:  MOVWF  44
....................                         copyData(); 
0102:  CALL   05E
....................                         forwrdFrameFlag = 1; 
0103:  BSF    4F.0
....................                         masterflag = 0; 
0104:  BCF    4F.2
....................                         backwardFrameFlag =0; 
0105:  BCF    4F.1
....................  
....................                   } 
0106:  GOTO   10E
....................                   else 
....................                   { 
.................... 						error_flag =1; 
0107:  BSF    31.4
.................... 						clear_interrupt(int_ext); 
0108:  BCF    0B.1
.................... 						enable_interrupts(INT_EXT); 
0109:  BSF    0B.4
....................     				  disable_interrupts(int_timer1); 
010A:  BSF    03.5
010B:  BCF    0C.0
....................     		          enable_interrupts(INT_RTCC); 
010C:  BCF    03.5
010D:  BSF    0B.5
....................                   } 
....................                   break; 
010E:  GOTO   12D
....................                } 
....................               	case 25: 
.................... 				{ 
.................... 					stopBitCount ++; 
010F:  INCF   4B,F
.................... 					break; 
0110:  GOTO   12D
.................... 				} 
....................               	case 26:  
.................... 				{ 
.................... 					stopBitCount ++; 
0111:  INCF   4B,F
.................... 					if(stopBitCount == 2) 
0112:  MOVF   4B,W
0113:  SUBLW  02
0114:  BTFSS  03.2
0115:  GOTO   11C
.................... 					{ 
.................... 						r_a=0;  
0116:  CLRF   44
.................... 						copyData(); 
0117:  CALL   05E
.................... 						forwrdFrameFlag =0; 
0118:  BCF    4F.0
.................... 						masterflag = 1; 
0119:  BSF    4F.2
.................... 						backwardFrameFlag =0; 
011A:  BCF    4F.1
.................... 					} 
011B:  GOTO   123
.................... 					else 
.................... 					{ 
.................... 						error_flag =1; 
011C:  BSF    31.4
.................... 						clear_interrupt(int_ext); 
011D:  BCF    0B.1
.................... 						enable_interrupts(INT_EXT); 
011E:  BSF    0B.4
....................     				  disable_interrupts(int_timer1); 
011F:  BSF    03.5
0120:  BCF    0C.0
....................     		          enable_interrupts(INT_RTCC); 
0121:  BCF    03.5
0122:  BSF    0B.5
.................... 					} 
.................... 					break; 
0123:  GOTO   12D
.................... 				} 
....................                 default: 
....................                 { 
....................                       error_flag=1; 
0124:  BSF    31.4
....................                       timerOnOff=0; 
0125:  BCF    10.0
.................... 					  clear_interrupt(int_ext); 
0126:  BCF    0B.1
....................                       enable_interrupts(INT_EXT); 
0127:  BSF    0B.4
....................     				  disable_interrupts(int_timer1); 
0128:  BSF    03.5
0129:  BCF    0C.0
....................     		          enable_interrupts(INT_RTCC); 
012A:  BCF    03.5
012B:  BSF    0B.5
....................                       settling_time = 0; 
012C:  CLRF   3D
....................                       break; 
....................                 } 
....................              }    
....................           }  
012D:  GOTO   137
.................... 		else 
.................... 		{ 
.................... 			error_flag=1;     
012E:  BSF    31.4
.................... 			settling_time = 0; 
012F:  CLRF   3D
.................... 			timerOnOff=0;     
0130:  BCF    10.0
.................... 			clear_interrupt(int_ext);    
0131:  BCF    0B.1
.................... 			enable_interrupts(INT_EXT); 
0132:  BSF    0B.4
....................     		disable_interrupts(int_timer1); 
0133:  BSF    03.5
0134:  BCF    0C.0
....................     		enable_interrupts(INT_RTCC);          
0135:  BCF    03.5
0136:  BSF    0B.5
.................... 		} 
....................       } 
0137:  GOTO   141
.................... 	else  										// The  data count is greater than 27  
.................... 	{ 
.................... 		over_flowflag =1 ; 
0138:  BSF    31.5
.................... 		settling_time = 0; 
0139:  CLRF   3D
.................... 		timerOnOff=0;    
013A:  BCF    10.0
.................... 		clear_interrupt(int_ext);     
013B:  BCF    0B.1
.................... 		enable_interrupts(INT_EXT); 
013C:  BSF    0B.4
....................         disable_interrupts(int_timer1); 
013D:  BSF    03.5
013E:  BCF    0C.0
....................         enable_interrupts(INT_RTCC);         
013F:  BCF    03.5
0140:  BSF    0B.5
.................... 	} 
....................     return; 
.................... } 
....................  
.................... void copyData(void) 
.................... {   
.................... 	dataReady =1;     
*
005E:  BSF    31.7
.................... 	if( r_a==1) 
005F:  DECFSZ 44,W
0060:  GOTO   066
.................... 	{ 
.................... 		address = data[1]; 
0061:  MOVF   34,W
0062:  MOVWF  4C
.................... 		command =data[0];						 
0063:  MOVF   33,W
0064:  MOVWF  4D
.................... 	} 
0065:  GOTO   06F
.................... 	else if( r_a==0) 
0066:  MOVF   44,F
0067:  BTFSS  03.2
0068:  GOTO   06F
.................... 	{	 
.................... 		address = data[2]; 
0069:  MOVF   35,W
006A:  MOVWF  4C
.................... 		command =data[1]; 
006B:  MOVF   34,W
006C:  MOVWF  4D
.................... 		databyte=data[0];  
006D:  MOVF   33,W
006E:  MOVWF  4E
.................... 	}        
....................     timerOnOff=0; 
006F:  BCF    10.0
....................     intf =0; 
0070:  BCF    0B.1
.................... 	clear_interrupt(int_ext); 
0071:  BCF    0B.1
....................     enable_interrupts(INT_EXT); 
0072:  BSF    0B.4
....................     disable_interrupts(int_timer1); 
0073:  BSF    03.5
0074:  BCF    0C.0
....................     enable_interrupts(INT_RTCC); 
0075:  BCF    03.5
0076:  BSF    0B.5
....................     settling_time = 0; 
0077:  CLRF   3D
....................     return; 
0078:  RETURN
.................... } 
....................  
....................  
.................... void commands(void)				// DALI commands decoder function 
.................... {  
.................... 	command_st =0;	 
*
03A6:  CLRF   47
.................... 	switch(command) 
03A7:  MOVF   4D,W
03A8:  XORLW  C9
03A9:  BTFSC  03.2
03AA:  GOTO   3EE
03AB:  XORLW  19
03AC:  BTFSC  03.2
03AD:  GOTO   403
03AE:  XORLW  04
03AF:  BTFSC  03.2
03B0:  GOTO   407
03B1:  XORLW  0C
03B2:  BTFSC  03.2
03B3:  GOTO   40A
03B4:  XORLW  29
03B5:  BTFSC  03.2
03B6:  GOTO   40A
03B7:  XORLW  2D
03B8:  BTFSC  03.2
03B9:  GOTO   415
03BA:  XORLW  2C
03BB:  BTFSC  03.2
03BC:  GOTO   415
03BD:  XORLW  1A
03BE:  BTFSC  03.2
03BF:  GOTO   420
03C0:  XORLW  0D
03C1:  BTFSC  03.2
03C2:  GOTO   43D
03C3:  XORLW  EE
03C4:  BTFSC  03.2
03C5:  GOTO   465
03C6:  XORLW  2B
03C7:  BTFSC  03.2
03C8:  GOTO   528
03C9:  XORLW  01
03CA:  BTFSC  03.2
03CB:  GOTO   54C
03CC:  XORLW  07
03CD:  BTFSC  03.2
03CE:  GOTO   551
03CF:  XORLW  01
03D0:  BTFSC  03.2
03D1:  GOTO   578
03D2:  XORLW  03
03D3:  BTFSC  03.2
03D4:  GOTO   581
03D5:  XORLW  01
03D6:  BTFSC  03.2
03D7:  GOTO   590
03D8:  XORLW  16
03D9:  BTFSC  03.2
03DA:  GOTO   59E
03DB:  XORLW  03
03DC:  BTFSC  03.2
03DD:  GOTO   5C6
03DE:  XORLW  01
03DF:  BTFSC  03.2
03E0:  GOTO   5D5
03E1:  XORLW  19
03E2:  BTFSC  03.2
03E3:  GOTO   5E4
03E4:  XORLW  01
03E5:  BTFSC  03.2
03E6:  GOTO   604
03E7:  XORLW  04
03E8:  BTFSC  03.2
03E9:  GOTO   624
03EA:  XORLW  1B
03EB:  BTFSC  03.2
03EC:  GOTO   644
03ED:  GOTO   64D
.................... 	{ 
....................  
.................... 	   	case 201:														// goto intermediate lux level ( range 0 to 100 ) 
.................... 		{   
.................... 			 
.................... 			if(databyte > MaximumLevel ) 
03EE:  MOVF   4E,W
03EF:  SUBWF  58,W
03F0:  BTFSC  03.0
03F1:  GOTO   3F5
.................... 			{ 
.................... 				duty = MaximumLevel; 
03F2:  MOVF   58,W
03F3:  MOVWF  38
.................... 			} 
03F4:  GOTO   3FE
.................... 			else if(databyte< MinimumLevel ) 
03F5:  MOVF   57,W
03F6:  SUBWF  4E,W
03F7:  BTFSC  03.0
03F8:  GOTO   3FC
.................... 		    { 
.................... 			duty = MinimumLevel; 
03F9:  MOVF   57,W
03FA:  MOVWF  38
.................... 			} 
03FB:  GOTO   3FE
.................... 			else 
.................... 			{ 
.................... 				duty =databyte; 
03FC:  MOVF   4E,W
03FD:  MOVWF  38
.................... 			} 		 
.................... 			lamp_on();		 
03FE:  CALL   2C1
.................... 			SetDimmLevel(duty);									 
03FF:  MOVF   38,W
0400:  MOVWF  5F
0401:  CALL   26A
.................... 			break; 
0402:  GOTO   64F
.................... 		} 
.................... 		case 208:														// Take the device  to full lux 
.................... 		{   
.................... 			 
.................... 			duty = MaximumLevel; 
0403:  MOVF   58,W
0404:  MOVWF  38
.................... 			lamp_on();	 
0405:  CALL   2C1
.................... 							 
.................... 			break; 
0406:  GOTO   64F
.................... 		} 
.................... 		case 212:														// Take the device to minimum lux 
.................... 		{   
.................... 			 
.................... 			duty =0; 
0407:  CLRF   38
.................... 			lamp_off(); 
0408:  CALL   2BC
.................... 			break; 
0409:  GOTO   64F
.................... 		} 
.................... 		case 216:														// Dim at individual device address			 
.................... 		case 241:														// Dim at zone address 
.................... 		{ 
.................... 			if(l_st==1) 
040A:  DECFSZ 46,W
040B:  GOTO   414
.................... 			{				 
.................... 				if(duty>MinimumLevel) 
040C:  MOVF   38,W
040D:  SUBWF  57,W
040E:  BTFSC  03.0
040F:  GOTO   414
.................... 				{							 
.................... 					duty--; 
0410:  DECF   38,F
.................... 					SetDimmLevel(duty);					 
0411:  MOVF   38,W
0412:  MOVWF  5F
0413:  CALL   26A
.................... 				} 
.................... 			} 
.................... 			break; 
0414:  GOTO   64F
.................... 		} 
.................... 		case 220:														// Bright at individual device address 
.................... 		case 240:  														// Bright at zone address 
.................... 		{ 
.................... 			if(l_st==1) 
0415:  DECFSZ 46,W
0416:  GOTO   41F
.................... 			{			 
.................... 				if(duty < MaximumLevel) 
0417:  MOVF   58,W
0418:  SUBWF  38,W
0419:  BTFSC  03.0
041A:  GOTO   41F
.................... 				{									 
.................... 					duty++; 
041B:  INCF   38,F
.................... 					SetDimmLevel(duty);			 
041C:  MOVF   38,W
041D:  MOVWF  5F
041E:  CALL   26A
.................... 				} 
.................... 			} 
.................... 			break; 
041F:  GOTO   64F
.................... 		}	 
.................... 	 
.................... 		case 234: 														// Select a scene from 0-15  
.................... 		{ 
.................... 			 
.................... 			if(databyte < 17) 
0420:  MOVF   4E,W
0421:  SUBLW  10
0422:  BTFSS  03.0
0423:  GOTO   43C
.................... 			{				 
.................... 				currentSceen = databyte;			 
0424:  MOVF   4E,W
0425:  MOVWF  45
.................... 		        duty = read_EEPROM (currentSceen+SceneStore);	 
0426:  MOVLW  09
0427:  ADDWF  45,W
0428:  MOVWF  5F
0429:  MOVF   5F,W
042A:  BSF    03.5
042B:  MOVWF  1B
042C:  BCF    1C.7
042D:  BSF    1C.0
042E:  MOVF   1A,W
042F:  BCF    03.5
0430:  MOVWF  38
.................... 			     	if(duty<=MinimumLevel) 
0431:  MOVF   38,W
0432:  SUBWF  57,W
0433:  BTFSS  03.0
0434:  GOTO   438
.................... 					{ 
.................... 						duty=0;					 
0435:  CLRF   38
.................... 						lamp_off();		 
0436:  CALL   2BC
.................... 					} 
0437:  GOTO   43C
.................... 					else 
.................... 					{								 
.................... 						lamp_on();	 
0438:  CALL   2C1
.................... 						SetDimmLevel(duty);		 
0439:  MOVF   38,W
043A:  MOVWF  5F
043B:  CALL   26A
.................... 					}			 
.................... 			} 
.................... 			break; 
043C:  GOTO   64F
.................... 		 } 
.................... 		case 231:  														// Store the current lux level of the device to a scene from 0-15 
.................... 		{ 
....................  
.................... 			if(databyte < 17) 
043D:  MOVF   4E,W
043E:  SUBLW  10
043F:  BTFSS  03.0
0440:  GOTO   464
.................... 			{				 
.................... 				disable_interrupts (global); 
0441:  BCF    0B.6
0442:  BCF    0B.7
0443:  BTFSC  0B.7
0444:  GOTO   442
.................... 				write_eeprom(databyte+SceneStore,duty); 
0445:  MOVLW  09
0446:  ADDWF  4E,W
0447:  MOVWF  5F
0448:  MOVF   0B,W
0449:  MOVWF  20
044A:  BCF    0B.7
044B:  MOVF   5F,W
044C:  BSF    03.5
044D:  MOVWF  1B
044E:  BCF    03.5
044F:  MOVF   38,W
0450:  BSF    03.5
0451:  MOVWF  1A
0452:  BCF    1C.7
0453:  BSF    1C.2
0454:  MOVLW  55
0455:  MOVWF  1D
0456:  MOVLW  AA
0457:  MOVWF  1D
0458:  BSF    1C.1
0459:  BTFSC  1C.1
045A:  GOTO   459
045B:  BCF    1C.2
045C:  BCF    03.5
045D:  MOVF   20,W
045E:  IORWF  0B,F
.................... 				delay_us(5);			 
045F:  GOTO   460
0460:  GOTO   461
0461:  NOP
.................... 				enable_interrupts(global);	 
0462:  MOVLW  C0
0463:  IORWF  0B,F
.................... 			} 
.................... 			break; 
0464:  GOTO   64F
.................... 		} 
.................... 		case 9:															// Add or Remove the device from a group from 0-15 
.................... 		{		 
.................... 				GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
0465:  MOVLW  08
0466:  BSF    03.5
0467:  MOVWF  1B
0468:  BCF    1C.7
0469:  BSF    1C.0
046A:  MOVF   1A,W
046B:  BCF    03.5
046C:  MOVWF  5F
046D:  MOVLW  07
046E:  BSF    03.5
046F:  MOVWF  1B
0470:  BCF    1C.7
0471:  BSF    1C.0
0472:  MOVF   1A,W
0473:  BCF    03.5
0474:  MOVWF  60
0475:  MOVF   5F,W
0476:  MOVWF  53
0477:  MOVF   60,W
0478:  MOVWF  52
.................... 				gindex = databyte &0x0f;				 
0479:  MOVF   4E,W
047A:  ANDLW  0F
047B:  MOVWF  54
.................... 				switch (databyte & 0x10) 
047C:  MOVF   4E,W
047D:  ANDLW  10
047E:  BTFSC  03.2
047F:  GOTO   484
0480:  XORLW  10
0481:  BTFSC  03.2
0482:  GOTO   4D8
0483:  GOTO   527
.................... 				{ 
.................... 					case 0: 
.................... 						{ 
.................... 							bit_clear(GroupSelectReg,gindex); 
0484:  CLRF   23
0485:  MOVLW  01
0486:  MOVWF  22
0487:  MOVF   54,W
0488:  MOVWF  20
0489:  BTFSC  03.2
048A:  GOTO   490
048B:  BCF    03.0
048C:  RLF    22,F
048D:  RLF    23,F
048E:  DECFSZ 20,F
048F:  GOTO   48B
0490:  MOVF   22,W
0491:  XORLW  FF
0492:  MOVWF  20
0493:  MOVLW  FF
0494:  XORWF  23,F
0495:  MOVF   20,W
0496:  ANDWF  52,F
0497:  MOVF   23,W
0498:  ANDWF  53,F
.................... 							write_eeprom(Group_07Store  ,make8(GroupSelectReg,0)); 
0499:  MOVF   52,W
049A:  MOVWF  5F
049B:  MOVF   0B,W
049C:  MOVWF  20
049D:  BCF    0B.7
049E:  MOVLW  07
049F:  BSF    03.5
04A0:  MOVWF  1B
04A1:  BCF    03.5
04A2:  MOVF   52,W
04A3:  BSF    03.5
04A4:  MOVWF  1A
04A5:  BCF    1C.7
04A6:  BSF    1C.2
04A7:  MOVLW  55
04A8:  MOVWF  1D
04A9:  MOVLW  AA
04AA:  MOVWF  1D
04AB:  BSF    1C.1
04AC:  BTFSC  1C.1
04AD:  GOTO   4AC
04AE:  BCF    1C.2
04AF:  BCF    03.5
04B0:  MOVF   20,W
04B1:  IORWF  0B,F
.................... 							delay_us(10); 
04B2:  MOVLW  02
04B3:  MOVWF  20
04B4:  DECFSZ 20,F
04B5:  GOTO   4B4
04B6:  GOTO   4B7
04B7:  NOP
.................... 							write_eeprom(Group_815Store,make8(GroupSelectReg,1)); 
04B8:  MOVF   53,W
04B9:  MOVWF  5F
04BA:  MOVF   0B,W
04BB:  MOVWF  20
04BC:  BCF    0B.7
04BD:  MOVLW  08
04BE:  BSF    03.5
04BF:  MOVWF  1B
04C0:  BCF    03.5
04C1:  MOVF   53,W
04C2:  BSF    03.5
04C3:  MOVWF  1A
04C4:  BCF    1C.7
04C5:  BSF    1C.2
04C6:  MOVLW  55
04C7:  MOVWF  1D
04C8:  MOVLW  AA
04C9:  MOVWF  1D
04CA:  BSF    1C.1
04CB:  BTFSC  1C.1
04CC:  GOTO   4CB
04CD:  BCF    1C.2
04CE:  BCF    03.5
04CF:  MOVF   20,W
04D0:  IORWF  0B,F
....................  							delay_us(10); 
04D1:  MOVLW  02
04D2:  MOVWF  20
04D3:  DECFSZ 20,F
04D4:  GOTO   4D3
04D5:  GOTO   4D6
04D6:  NOP
.................... 							break; 
04D7:  GOTO   527
.................... 						} 
.................... 					case 16: 
.................... 						{ 
.................... 							bit_set(GroupSelectReg,gindex); 
04D8:  CLRF   23
04D9:  MOVLW  01
04DA:  MOVWF  22
04DB:  MOVF   54,W
04DC:  MOVWF  20
04DD:  BTFSC  03.2
04DE:  GOTO   4E4
04DF:  BCF    03.0
04E0:  RLF    22,F
04E1:  RLF    23,F
04E2:  DECFSZ 20,F
04E3:  GOTO   4DF
04E4:  MOVF   22,W
04E5:  IORWF  52,F
04E6:  MOVF   23,W
04E7:  IORWF  53,F
.................... 							write_eeprom(Group_07Store  ,make8(GroupSelectReg,0)); 
04E8:  MOVF   52,W
04E9:  MOVWF  5F
04EA:  MOVF   0B,W
04EB:  MOVWF  20
04EC:  BCF    0B.7
04ED:  MOVLW  07
04EE:  BSF    03.5
04EF:  MOVWF  1B
04F0:  BCF    03.5
04F1:  MOVF   52,W
04F2:  BSF    03.5
04F3:  MOVWF  1A
04F4:  BCF    1C.7
04F5:  BSF    1C.2
04F6:  MOVLW  55
04F7:  MOVWF  1D
04F8:  MOVLW  AA
04F9:  MOVWF  1D
04FA:  BSF    1C.1
04FB:  BTFSC  1C.1
04FC:  GOTO   4FB
04FD:  BCF    1C.2
04FE:  BCF    03.5
04FF:  MOVF   20,W
0500:  IORWF  0B,F
.................... 							delay_us(10); 
0501:  MOVLW  02
0502:  MOVWF  20
0503:  DECFSZ 20,F
0504:  GOTO   503
0505:  GOTO   506
0506:  NOP
.................... 							write_eeprom(Group_815Store,make8(GroupSelectReg,1)); 
0507:  MOVF   53,W
0508:  MOVWF  5F
0509:  MOVF   0B,W
050A:  MOVWF  20
050B:  BCF    0B.7
050C:  MOVLW  08
050D:  BSF    03.5
050E:  MOVWF  1B
050F:  BCF    03.5
0510:  MOVF   53,W
0511:  BSF    03.5
0512:  MOVWF  1A
0513:  BCF    1C.7
0514:  BSF    1C.2
0515:  MOVLW  55
0516:  MOVWF  1D
0517:  MOVLW  AA
0518:  MOVWF  1D
0519:  BSF    1C.1
051A:  BTFSC  1C.1
051B:  GOTO   51A
051C:  BCF    1C.2
051D:  BCF    03.5
051E:  MOVF   20,W
051F:  IORWF  0B,F
....................  							delay_us(10); 
0520:  MOVLW  02
0521:  MOVWF  20
0522:  DECFSZ 20,F
0523:  GOTO   522
0524:  GOTO   525
0525:  NOP
.................... 							break; 
0526:  GOTO   527
.................... 						} 
.................... 					 
.................... 					default: break; 
....................  
.................... 				} 
.................... 				break ; 
0527:  GOTO   64F
.................... 		} 
.................... 		case 34:    													// Write short address alias lampid 
.................... 		{ 
.................... 			if(databyte <64) 
0528:  MOVF   4E,W
0529:  SUBLW  3F
052A:  BTFSS  03.0
052B:  GOTO   54B
.................... 			{ 
.................... 					lampid = databyte; 
052C:  MOVF   4E,W
052D:  MOVWF  5E
.................... 					write_eeprom(ShortAddressStore ,lampid); 
052E:  MOVF   0B,W
052F:  MOVWF  20
0530:  BCF    0B.7
0531:  MOVLW  06
0532:  BSF    03.5
0533:  MOVWF  1B
0534:  BCF    03.5
0535:  MOVF   5E,W
0536:  BSF    03.5
0537:  MOVWF  1A
0538:  BCF    1C.7
0539:  BSF    1C.2
053A:  MOVLW  55
053B:  MOVWF  1D
053C:  MOVLW  AA
053D:  MOVWF  1D
053E:  BSF    1C.1
053F:  BTFSC  1C.1
0540:  GOTO   53F
0541:  BCF    1C.2
0542:  BCF    03.5
0543:  MOVF   20,W
0544:  IORWF  0B,F
.................... 					delay_us(10); 
0545:  MOVLW  02
0546:  MOVWF  20
0547:  DECFSZ 20,F
0548:  GOTO   547
0549:  GOTO   54A
054A:  NOP
.................... 			} 
.................... 		 
.................... 			break;		 
054B:  GOTO   64F
.................... 		} 
.................... 		case 35:    													// Write the desired data value to DTR register  
.................... 		{ 
.................... 					DTR = databyte;	 
054C:  MOVF   4E,W
054D:  MOVWF  5B
.................... 					DTR_Ready =1; 
054E:  MOVLW  01
054F:  MOVWF  5D
.................... 					break; 
0550:  GOTO   64F
.................... 		} 
.................... 		case 36:    													// Write the value stored in DTR to the desired address location  
.................... 		{ 
.................... 					 
.................... 				DwriteLocation = databyte;	 
0551:  MOVF   4E,W
0552:  MOVWF  5C
.................... 				if(DTR_Ready ==1 && DwriteLocation<33 ) 
0553:  DECFSZ 5D,W
0554:  GOTO   576
0555:  MOVF   5C,W
0556:  SUBLW  20
0557:  BTFSS  03.0
0558:  GOTO   576
.................... 				{ 
.................... 					DTR_Ready =0; 
0559:  CLRF   5D
.................... 					write_eeprom(DwriteLocation,DTR); 
055A:  MOVF   0B,W
055B:  MOVWF  20
055C:  BCF    0B.7
055D:  MOVF   5C,W
055E:  BSF    03.5
055F:  MOVWF  1B
0560:  BCF    03.5
0561:  MOVF   5B,W
0562:  BSF    03.5
0563:  MOVWF  1A
0564:  BCF    1C.7
0565:  BSF    1C.2
0566:  MOVLW  55
0567:  MOVWF  1D
0568:  MOVLW  AA
0569:  MOVWF  1D
056A:  BSF    1C.1
056B:  BTFSC  1C.1
056C:  GOTO   56B
056D:  BCF    1C.2
056E:  BCF    03.5
056F:  MOVF   20,W
0570:  IORWF  0B,F
.................... 					DELAY_US(20); 
0571:  MOVLW  06
0572:  MOVWF  20
0573:  DECFSZ 20,F
0574:  GOTO   573
0575:  NOP
.................... 				} 
.................... 			init_from_eeprom(); 
0576:  CALL   1AF
.................... 			break; 
0577:  GOTO   64F
.................... 		} 
.................... 		case 37:    													// Read the value stored in DTR register of the device  
.................... 		{ 
.................... 				tx_buffer[2]=lampid;tx_buffer[1]=DTR; txmit(2,2);  
0578:  MOVF   5E,W
0579:  MOVWF  43
057A:  MOVF   5B,W
057B:  MOVWF  42
057C:  MOVLW  02
057D:  MOVWF  5F
057E:  MOVWF  60
057F:  CALL   337
.................... 				break;			 
0580:  GOTO   64F
.................... 		} 
.................... 		case 38:    													// Store the desired EEPROM location value to DTR register 
.................... 		{ 
.................... 				DwriteLocation = databyte;	 
0581:  MOVF   4E,W
0582:  MOVWF  5C
.................... 				if( DwriteLocation<33 ) 
0583:  MOVF   5C,W
0584:  SUBLW  20
0585:  BTFSS  03.0
0586:  GOTO   58F
.................... 				{ 
.................... 					DTR=Read_eeprom(DwriteLocation); 
0587:  MOVF   5C,W
0588:  BSF    03.5
0589:  MOVWF  1B
058A:  BCF    1C.7
058B:  BSF    1C.0
058C:  MOVF   1A,W
058D:  BCF    03.5
058E:  MOVWF  5B
.................... 				}	 
.................... 				break;				 
058F:  GOTO   64F
.................... 		} 
.................... 		case 39:														// Read the current lux level of the device 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=Read_eeprom(0);  
0590:  MOVF   5E,W
0591:  MOVWF  43
0592:  BSF    03.5
0593:  CLRF   1B
0594:  BCF    1C.7
0595:  BSF    1C.0
0596:  MOVF   1A,W
0597:  BCF    03.5
0598:  MOVWF  42
.................... 	    	txmit(2,2);		 
0599:  MOVLW  02
059A:  MOVWF  5F
059B:  MOVWF  60
059C:  CALL   337
.................... 			break; 
059D:  GOTO   64F
.................... 		} 
.................... 		case 49: 														// Write Zone ID of the device to corresponding EEPROM location 
.................... 		{ 
.................... 			if(databyte >=208 && databyte <=223) 
059E:  MOVF   4E,W
059F:  SUBLW  CF
05A0:  BTFSC  03.0
05A1:  GOTO   5C5
05A2:  MOVF   4E,W
05A3:  SUBLW  DF
05A4:  BTFSS  03.0
05A5:  GOTO   5C5
.................... 			{ 
.................... 					zoneid = databyte; 
05A6:  MOVF   4E,W
05A7:  MOVWF  4A
.................... 					write_eeprom(ZoneIDStore ,zoneid); 
05A8:  MOVF   0B,W
05A9:  MOVWF  20
05AA:  BCF    0B.7
05AB:  MOVLW  20
05AC:  BSF    03.5
05AD:  MOVWF  1B
05AE:  BCF    03.5
05AF:  MOVF   4A,W
05B0:  BSF    03.5
05B1:  MOVWF  1A
05B2:  BCF    1C.7
05B3:  BSF    1C.2
05B4:  MOVLW  55
05B5:  MOVWF  1D
05B6:  MOVLW  AA
05B7:  MOVWF  1D
05B8:  BSF    1C.1
05B9:  BTFSC  1C.1
05BA:  GOTO   5B9
05BB:  BCF    1C.2
05BC:  BCF    03.5
05BD:  MOVF   20,W
05BE:  IORWF  0B,F
.................... 					delay_us(10); 
05BF:  MOVLW  02
05C0:  MOVWF  20
05C1:  DECFSZ 20,F
05C2:  GOTO   5C1
05C3:  GOTO   5C4
05C4:  NOP
.................... 			}		 
.................... 			break; 
05C5:  GOTO   64F
....................  
.................... 		} 
.................... 		case 50: 														// Read first group section byte status ( 0 -  absent in the grp, 1 - present in the group ) 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=Read_eeprom(7);  
05C6:  MOVF   5E,W
05C7:  MOVWF  43
05C8:  MOVLW  07
05C9:  BSF    03.5
05CA:  MOVWF  1B
05CB:  BCF    1C.7
05CC:  BSF    1C.0
05CD:  MOVF   1A,W
05CE:  BCF    03.5
05CF:  MOVWF  42
.................... 			txmit(2,2);			 
05D0:  MOVLW  02
05D1:  MOVWF  5F
05D2:  MOVWF  60
05D3:  CALL   337
.................... 			break; 
05D4:  GOTO   64F
....................  
.................... 		} 
.................... 		case 51: 														// Read second group section byte status ( 0 -  absent in the grp, 1 - present in the group ) 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=Read_eeprom(8);  
05D5:  MOVF   5E,W
05D6:  MOVWF  43
05D7:  MOVLW  08
05D8:  BSF    03.5
05D9:  MOVWF  1B
05DA:  BCF    1C.7
05DB:  BSF    1C.0
05DC:  MOVF   1A,W
05DD:  BCF    03.5
05DE:  MOVWF  42
.................... 			txmit(2,2);			 
05DF:  MOVLW  02
05E0:  MOVWF  5F
05E1:  MOVWF  60
05E2:  CALL   337
.................... 			break; 
05E3:  GOTO   64F
....................  
.................... 		} 
.................... 		case 42: 														// Write Maximum lux level of the device 
.................... 		{ 
.................... 			MaximumLevel=databyte; 
05E4:  MOVF   4E,W
05E5:  MOVWF  58
.................... 			write_eeprom(MaximumLevelStore,MaximumLevel); 
05E6:  MOVF   0B,W
05E7:  MOVWF  20
05E8:  BCF    0B.7
05E9:  MOVLW  03
05EA:  BSF    03.5
05EB:  MOVWF  1B
05EC:  BCF    03.5
05ED:  MOVF   58,W
05EE:  BSF    03.5
05EF:  MOVWF  1A
05F0:  BCF    1C.7
05F1:  BSF    1C.2
05F2:  MOVLW  55
05F3:  MOVWF  1D
05F4:  MOVLW  AA
05F5:  MOVWF  1D
05F6:  BSF    1C.1
05F7:  BTFSC  1C.1
05F8:  GOTO   5F7
05F9:  BCF    1C.2
05FA:  BCF    03.5
05FB:  MOVF   20,W
05FC:  IORWF  0B,F
.................... 			delay_us(10);			 
05FD:  MOVLW  02
05FE:  MOVWF  20
05FF:  DECFSZ 20,F
0600:  GOTO   5FF
0601:  GOTO   602
0602:  NOP
.................... 			break; 
0603:  GOTO   64F
....................  
.................... 		} 
.................... 		case 43: 														// Write Minimum lux level of the device 
.................... 		{ 
.................... 			MaximumLevel=databyte; 
0604:  MOVF   4E,W
0605:  MOVWF  58
.................... 			write_eeprom(MinimumLevelStore,MinimumLevel); 
0606:  MOVF   0B,W
0607:  MOVWF  20
0608:  BCF    0B.7
0609:  MOVLW  02
060A:  BSF    03.5
060B:  MOVWF  1B
060C:  BCF    03.5
060D:  MOVF   57,W
060E:  BSF    03.5
060F:  MOVWF  1A
0610:  BCF    1C.7
0611:  BSF    1C.2
0612:  MOVLW  55
0613:  MOVWF  1D
0614:  MOVLW  AA
0615:  MOVWF  1D
0616:  BSF    1C.1
0617:  BTFSC  1C.1
0618:  GOTO   617
0619:  BCF    1C.2
061A:  BCF    03.5
061B:  MOVF   20,W
061C:  IORWF  0B,F
.................... 			delay_us(10);		 
061D:  MOVLW  02
061E:  MOVWF  20
061F:  DECFSZ 20,F
0620:  GOTO   61F
0621:  GOTO   622
0622:  NOP
.................... 			break; 
0623:  GOTO   64F
.................... 		} 
.................... 		case 47:														// Write FadeRate of the device 
.................... 		{ 
.................... 			FadeRate=databyte; 
0624:  MOVF   4E,W
0625:  MOVWF  59
.................... 			write_eeprom(FadeRateStore,FadeRate); 
0626:  MOVF   0B,W
0627:  MOVWF  20
0628:  BCF    0B.7
0629:  MOVLW  04
062A:  BSF    03.5
062B:  MOVWF  1B
062C:  BCF    03.5
062D:  MOVF   59,W
062E:  BSF    03.5
062F:  MOVWF  1A
0630:  BCF    1C.7
0631:  BSF    1C.2
0632:  MOVLW  55
0633:  MOVWF  1D
0634:  MOVLW  AA
0635:  MOVWF  1D
0636:  BSF    1C.1
0637:  BTFSC  1C.1
0638:  GOTO   637
0639:  BCF    1C.2
063A:  BCF    03.5
063B:  MOVF   20,W
063C:  IORWF  0B,F
.................... 			delay_us(10);		 
063D:  MOVLW  02
063E:  MOVWF  20
063F:  DECFSZ 20,F
0640:  GOTO   63F
0641:  GOTO   642
0642:  NOP
.................... 			break; 
0643:  GOTO   64F
.................... 		} 
.................... 		case 52:														// Read code version of the device 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=1;  
0644:  MOVF   5E,W
0645:  MOVWF  43
0646:  MOVLW  01
0647:  MOVWF  42
.................... 			txmit(2,2);			 
0648:  MOVLW  02
0649:  MOVWF  5F
064A:  MOVWF  60
064B:  CALL   337
.................... 			break; 
064C:  GOTO   64F
.................... 		} 
.................... 		default: 
.................... 		{ 
.................... 			command_st=1; 
064D:  MOVLW  01
064E:  MOVWF  47
.................... 			break; 
.................... 		} 
.................... 	} 
.................... 	if(command_st==0) 
064F:  MOVF   47,F
0650:  BTFSS  03.2
0651:  GOTO   668
.................... 	{ 		 
.................... 		  write_eeprom(PowerOnLevelStore,duty);							// Write current lux level to EEPROM location 
0652:  MOVF   0B,W
0653:  MOVWF  20
0654:  BCF    0B.7
0655:  BSF    03.5
0656:  CLRF   1B
0657:  BCF    03.5
0658:  MOVF   38,W
0659:  BSF    03.5
065A:  MOVWF  1A
065B:  BCF    1C.7
065C:  BSF    1C.2
065D:  MOVLW  55
065E:  MOVWF  1D
065F:  MOVLW  AA
0660:  MOVWF  1D
0661:  BSF    1C.1
0662:  BTFSC  1C.1
0663:  GOTO   662
0664:  BCF    1C.2
0665:  BCF    03.5
0666:  MOVF   20,W
0667:  IORWF  0B,F
.................... 	} 
.................... return; 
.................... } 
....................  
.................... void lamp_on()															// Taking to corresponding lux level 
.................... {	 
.................... 	SetDimmLevel(duty); 
*
02C1:  MOVF   38,W
02C2:  MOVWF  5F
02C3:  CALL   26A
.................... 	l_st=1; 
02C4:  MOVLW  01
02C5:  MOVWF  46
.................... 	return; 
02C6:  RETURN
.................... } 
.................... 	 
.................... void lamp_off()															// Taking to Minimum lux level 
.................... {	 
.................... 	SetDimmLevel(MinimumLevel);	 
*
02BC:  MOVF   57,W
02BD:  MOVWF  5F
02BE:  CALL   26A
.................... 	l_st=0; 
02BF:  CLRF   46
.................... 	return; 
02C0:  RETURN
.................... } 
.................... 	 
.................... void SetDimmLevel(unsigned int dimPesentage)							// Mapping lux level of 0-100 to PWM levels of 0-1023 
.................... { 
.................... 	if(dimPesentage > MaximumLevel) 
*
026A:  MOVF   5F,W
026B:  SUBWF  58,W
026C:  BTFSC  03.0
026D:  GOTO   270
.................... 		{ 
.................... 			dimPesentage = MaximumLevel; 
026E:  MOVF   58,W
026F:  MOVWF  5F
.................... 		}	 
.................... 	if(dimPesentage<10)											// Strip driver mapping 
0270:  MOVF   5F,W
0271:  SUBLW  09
0272:  BTFSS  03.0
0273:  GOTO   278
.................... 	{ 
.................... 		Power =dimPesentage; 
0274:  CLRF   3C
0275:  MOVF   5F,W
0276:  MOVWF  3B
.................... 	} 
0277:  GOTO   2AC
.................... 	else if(dimPesentage<30) 
0278:  MOVF   5F,W
0279:  SUBLW  1D
027A:  BTFSS  03.0
027B:  GOTO   28B
.................... 	{ 
.................... 		Power =10+_mul((dimPesentage-10),2); 
027C:  MOVLW  0A
027D:  SUBWF  5F,W
027E:  MOVWF  60
027F:  MOVWF  61
0280:  MOVLW  02
0281:  MOVWF  62
0282:  CALL   245
0283:  MOVF   21,W
0284:  ADDLW  0A
0285:  MOVWF  3B
0286:  MOVF   20,W
0287:  MOVWF  3C
0288:  BTFSC  03.0
0289:  INCF   3C,F
.................... 	} 
028A:  GOTO   2AC
.................... 	else if(dimPesentage<60) 
028B:  MOVF   5F,W
028C:  SUBLW  3B
028D:  BTFSS  03.0
028E:  GOTO   29E
.................... 	{ 
.................... 		Power =50+_mul((dimPesentage-30),5); 
028F:  MOVLW  1E
0290:  SUBWF  5F,W
0291:  MOVWF  60
0292:  MOVWF  61
0293:  MOVLW  05
0294:  MOVWF  62
0295:  CALL   245
0296:  MOVF   21,W
0297:  ADDLW  32
0298:  MOVWF  3B
0299:  MOVF   20,W
029A:  MOVWF  3C
029B:  BTFSC  03.0
029C:  INCF   3C,F
.................... 	} 
029D:  GOTO   2AC
.................... 	else 
.................... 	{ 
.................... 		Power =195+ _mul(dimPesentage-60,10); 
029E:  MOVLW  3C
029F:  SUBWF  5F,W
02A0:  MOVWF  60
02A1:  MOVWF  61
02A2:  MOVLW  0A
02A3:  MOVWF  62
02A4:  CALL   245
02A5:  MOVF   21,W
02A6:  ADDLW  C3
02A7:  MOVWF  3B
02A8:  MOVF   20,W
02A9:  MOVWF  3C
02AA:  BTFSC  03.0
02AB:  INCF   3C,F
.................... 	}	 
.................... 	if(Power > 1020) 
02AC:  MOVF   3C,W
02AD:  SUBLW  02
02AE:  BTFSC  03.0
02AF:  GOTO   2BB
02B0:  XORLW  FF
02B1:  BTFSS  03.2
02B2:  GOTO   2B7
02B3:  MOVF   3B,W
02B4:  SUBLW  FC
02B5:  BTFSC  03.0
02B6:  GOTO   2BB
.................... 	{ 
.................... 		Power =1020; 
02B7:  MOVLW  03
02B8:  MOVWF  3C
02B9:  MOVLW  FC
02BA:  MOVWF  3B
.................... 	}	 
02BB:  RETURN
....................  
.................... /* 
....................   	if(dimPesentage<10)											// Normal driver mapping 
.................... 	{ 
.................... 		Power =_mul(dimPesentage,10); 
.................... 	} 
.................... 	else if(dimPesentage<90) 
.................... 	{ 
.................... 		Power =_mul((dimPesentage-10),4)+100; 
.................... 	} 
.................... 	else if(dimPesentage<=100) 
.................... 	{ 
.................... 		//Power =_mul(dimPesentage,6); 
.................... 		Power =_mul(dimPesentage-89,45)+570; 
.................... 	}	 
.................... 	if(Power > 1020){Power =1020;}	 
.................... */ 
....................  
.................... 	} 
....................  
....................  
.................... void init_from_eeprom(void)									// Reading values from EEPROM locations 
.................... { 
.................... 	GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
*
01AF:  MOVLW  08
01B0:  BSF    03.5
01B1:  MOVWF  1B
01B2:  BCF    1C.7
01B3:  BSF    1C.0
01B4:  MOVF   1A,W
01B5:  BCF    03.5
01B6:  MOVWF  5F
01B7:  MOVLW  07
01B8:  BSF    03.5
01B9:  MOVWF  1B
01BA:  BCF    1C.7
01BB:  BSF    1C.0
01BC:  MOVF   1A,W
01BD:  BCF    03.5
01BE:  MOVWF  60
01BF:  MOVF   5F,W
01C0:  MOVWF  53
01C1:  MOVF   60,W
01C2:  MOVWF  52
.................... 	delay_us(10); 
01C3:  MOVLW  02
01C4:  MOVWF  20
01C5:  DECFSZ 20,F
01C6:  GOTO   1C5
01C7:  GOTO   1C8
01C8:  NOP
.................... 	PowerOnLevel 		= 	read_EEPROM (PowerOnLevelStore); 
01C9:  BSF    03.5
01CA:  CLRF   1B
01CB:  BCF    1C.7
01CC:  BSF    1C.0
01CD:  MOVF   1A,W
01CE:  BCF    03.5
01CF:  MOVWF  5A
.................... 	delay_us(10); 	     
01D0:  MOVLW  02
01D1:  MOVWF  20
01D2:  DECFSZ 20,F
01D3:  GOTO   1D2
01D4:  GOTO   1D5
01D5:  NOP
.................... 	MinimumLevel		= 	read_EEPROM ( MinimumLevelStore );    
01D6:  MOVLW  02
01D7:  BSF    03.5
01D8:  MOVWF  1B
01D9:  BCF    1C.7
01DA:  BSF    1C.0
01DB:  MOVF   1A,W
01DC:  BCF    03.5
01DD:  MOVWF  57
.................... 	delay_us(10);       	 
01DE:  MOVLW  02
01DF:  MOVWF  20
01E0:  DECFSZ 20,F
01E1:  GOTO   1E0
01E2:  GOTO   1E3
01E3:  NOP
.................... 	MaximumLevel 		= 	read_EEPROM ( MaximumLevelStore);  
01E4:  MOVLW  03
01E5:  BSF    03.5
01E6:  MOVWF  1B
01E7:  BCF    1C.7
01E8:  BSF    1C.0
01E9:  MOVF   1A,W
01EA:  BCF    03.5
01EB:  MOVWF  58
.................... 	delay_us(10);  		 
01EC:  MOVLW  02
01ED:  MOVWF  20
01EE:  DECFSZ 20,F
01EF:  GOTO   1EE
01F0:  GOTO   1F1
01F1:  NOP
.................... 	FadeRate 			= 	read_EEPROM ( FadeRateStore); 
01F2:  MOVLW  04
01F3:  BSF    03.5
01F4:  MOVWF  1B
01F5:  BCF    1C.7
01F6:  BSF    1C.0
01F7:  MOVF   1A,W
01F8:  BCF    03.5
01F9:  MOVWF  59
.................... 	delay_us(10); 
01FA:  MOVLW  02
01FB:  MOVWF  20
01FC:  DECFSZ 20,F
01FD:  GOTO   1FC
01FE:  GOTO   1FF
01FF:  NOP
.................... 	lampid 				=	read_EEPROM ( ShortAddressStore ); 
0200:  MOVLW  06
0201:  BSF    03.5
0202:  MOVWF  1B
0203:  BCF    1C.7
0204:  BSF    1C.0
0205:  MOVF   1A,W
0206:  BCF    03.5
0207:  MOVWF  5E
.................... 	delay_us(10); 
0208:  MOVLW  02
0209:  MOVWF  20
020A:  DECFSZ 20,F
020B:  GOTO   20A
020C:  GOTO   20D
020D:  NOP
.................... 	zoneid				=	read_EEPROM(zoneidstore); 
020E:  MOVLW  20
020F:  BSF    03.5
0210:  MOVWF  1B
0211:  BCF    1C.7
0212:  BSF    1C.0
0213:  MOVF   1A,W
0214:  BCF    03.5
0215:  MOVWF  4A
.................... 	delay_us(10);  
0216:  MOVLW  02
0217:  MOVWF  20
0218:  DECFSZ 20,F
0219:  GOTO   218
021A:  GOTO   21B
021B:  NOP
021C:  RETURN
.................... } 
....................  
....................  

Configuration Fuses:
   Word  1: 33EC   INTRC_IO WDT PUT MCLR NOPROTECT NOCPD BROWNOUT NOIESO NOFCMEN

ROM data:
002100: 0064 0032 0000 0064 0005 0006 0001 0001 
002108: 0000 0006 0007 0008 

002120: 00D2 
